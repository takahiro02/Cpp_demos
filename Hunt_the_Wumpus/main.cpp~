
#include "./std_lib_facilities.h"
#include<limits>		// for std::numeric_limits::lowest()
#include<algorithm>		// for std::random_shuffle()
#include <chrono>       // std::chrono::system_clock for random engine seed in Ex 12

// since several functions defined in exercise 1,2,3 overlaps their names and argument
// types with std functions declared in string.h, I include these functions inside
// a namespace to differentiate them
namespace char_func{
// from p653
// Since strlen(const char*) is also defined in standard library, I had to change either
// its argument or name, so I changed it to Strlen from strlen
int strlen(const char* p, int max_num=128){ // max_num <- for Exercise 4
  int count = 0;
  while(*p){
    ++count; ++p;
    if(count >= max_num)	// for Ex 4
      break;
  }
  return count;
}

// Ex 1
// In Ex 4, I added the additional argument max_num with the default value. Then, the
// compiler starts to generate ambiguous function call error. It seems there is 
// char    *strdup(const char *__s1); declared in string.h. The name and argument type
// is exactly the same as my strdup() before adding max_num, but before adding max_num,
// g++ (clang) didn't generate any error, which is strange. And after I added the
// additional argument, g++ starts to generate the ambiguous function call error,
// which is also strange.
// A seemingly relevant question is https://stackoverflow.com/questions/43263880/
// According to the post, such a behavior is compiler-specific (gcc compiler seems to
// generate ambiguous function call error). And it's possible that such behavior is
// a bug in clang
char* strdup(const char* cstr, int max_num=128){
  if(cstr == nullptr) return nullptr;

  int len = strlen(cstr, max_num);
  //cout << len << endl;
  char* copy_cstr = new char[len+1]; // +1 is for the termination symbol '\0'
  for(int i=0; i<len; ++i)
    *(copy_cstr+i) = *(cstr+i);
  // at the end, pat '\0'
  *(copy_cstr+len) = '\0';
  return copy_cstr;
}

// Ex 2
// I made the return type const char* instead of char*, since compiler complained that
// "error: cannot initialize return object of type 'char *' with an rvalue of type
// 'const char *'"
// const char* return type makes more sense because the passed char array might be
// immutable.
const char* findx(const char* s, const char* x, int max_num=128){
  int lens = strlen(s, max_num);
  int lenx = strlen(x, max_num);
  if(lens < lenx) return nullptr;
  int sum{0};
  for(int i=0; i<lens-lenx+1; ++i){
    /* 
    // The following code also works, but not elegant. It is based on how humans check 
    // substrings, and on code, it looks messy.
    // The 2nd version is more elegant, easier to read, with the same time complexity
    if(*(x) == *(s+i)){		// 1st letter is the same
      // check if the rest is also the same
      bool same{true};
      for(int j=1; j<lenx; ++j){
	if(*(x+j) != *(s+i+j)){
	  same = false;
	  break;
	}
      }
      if(same)		// this means there exists string x in s
	return s+i;	// s+i is the start of the substring equal to x in s
    }
    */

    // The following 2nd version is based on how characters are stored internally in
    // machine memory. They are stored in a number, an int, based on ASCII code.
    // If a substring in s is the same as x, the subtraction of them becomes 0.
    // The 2nd version is based on that view of memory.
    sum = 0;
    for(int j=0; j<lenx; ++j){
      sum += *(s+i+j) - *(x+j);
      if(sum != 0) break;
    }
    // When reaching here, if the sum stays 0, that means all the subtractions on each
    // character are done, and all the results become 0
    if(sum == 0) return s+i;

    // The 2nd version looks more elegant, easier to read
    // I felt sometimes elegant code is closer to how machine would think, instead of
    // tracing how humans think the problem, and writing down the trace.
    // For example, the calculator code in this book works elegantly (though it is
    // difficult to read), and the code is a little distant from how humans process
    // calculations.
  }
  return nullptr;		// no substring in s that is equal to x
}

// Ex 3
char to_lower(char ch){
  if(ch>=65 && ch<=90)
    ch += 32;
  return ch;
}
bool is_alpha(char ch){		// checks if the character is alphabet based on ASCII code
  if((ch>=65 && ch<=90) || (ch>=97 && ch<=122))
    return true;
  return false;
}

// Ex 3
// Ex 4 for adding the additional argument max_num
int strcmp(const char* s1, const char* s2, int max_num=128){
  int lens1 = strlen(s1, max_num);
  int lens2 = strlen(s2, max_num);
  int i{0}, j{0};      // indices of s1 and s2
  // keep track of s1 and s2 individually, since this function ignores non-alphabet
  // characters
  char ch1, ch2;
  
  while(i<lens1 && j<lens2){
    ch1 = *(s1+i);
    ch2 = *(s2+j);
    if(!is_alpha(ch1)){
      ++i;
      continue;
    }
    if(!is_alpha(ch2)){
      ++j;
      continue;
    }
    // convert to small letter if they are capital
    ch1 = to_lower(ch1);
    ch2 = to_lower(ch2);
    if(ch1 < ch2) return -1;
    else if(ch1 > ch2) return 1;
    else{			// case where ch1 == ch2
      ++i;
      ++j;
    }
  }

  // reaching here means s1 and s2 are lexicographically the same up to lens1 or lens2
  if(i==lens1 && j==lens2) return 0;
  else if(i==lens1){		// case where j < lens2
    // check if any alphabet exists after j in s2 (because this function is meant to
    // ignore non-alphabet)
    for(int k=j+1; k<lens2; ++k){
      if(is_alpha(*(s2+k))) return -1;
    }
    return 0;
  }
  else{				// case where i < lens1
    // the same check as the above case
    for(int k=i+1; k<lens1; ++k){
      if(is_alpha(*(s1+k))) return -1;
    }
    return 0;
  }
}
};				// namespace char_func


// Ex 8
bool is_palindrome(const string& s){
  // copy s backward
  string back_s;
  for(int i=s.size()-1; i>=0; --i)
    back_s.push_back(s[i]);

  // compare those 2 strings from the front
  for(int i=0; i<s.size(); ++i)
    if(s[i] != back_s[i]) return false;
  return true;
}

bool is_palindrome(const char s[], int n){
  char* back_s = new char[n];
  // careful: char back_s[n]; is an error, as p649 says. The size of an array must be
  // known at compile time. If the size is unknown, we need to use allocated memory.
  // Also be careful, that char back_s[] is not equal to char* back_s here. That
  // conversion from <type> a[] -> <type>* a happens only in function arguments (p653)
  // By the way, since back_s is not printed on screen, we don't need to pad '\0'
  // at the end of it. So the number of elements can be n, instead of n+1
  
  // copy backward
  for(int i=0; i<n; ++i)
    back_s[i] = s[n-i-1];	// careful: s[n-1] is the last element, s[n] == '\0'
  
  // compare those 2 arrays
  for(int i=0; i<n; ++i)
    if(s[i] != back_s[i]){
      delete[] back_s;
      // don't forget to delete[] the allocated array before exiting this function
      return false;
    }
  delete[] back_s;
  return true;
}

// from p660-661
istream& read_word(istream& is, char* buffer, int max){
  is.width(max);		// read at most max-1 characters in the next >>
  is >> buffer;			// read white-space-terminated word
  // add 0 after the last character read into buffer
  return is;
}

// using pointers 1
bool is_palindrome(const char* first){
  // in this version of copying the string backward, we don't need the pointer to the
  // last element anymore
  int n{char_func::strlen(first)};
  char* back_s = new char[n];
  
  // copy backward
  for(int i=0; i<n; ++i)
    back_s[i] = first[n-1-i];	// careful: s[n-1] is the last element, s[n] == '\0'
  
  // compare those 2 arrays
  for(int i=0; i<n; ++i)
    if(first[i] != back_s[i]){
      delete[] back_s;
      // don't forget to delete[] the allocated array before exiting this function
      return false;
    }
  delete[] back_s;
  return true;
}

// using pointers 2 using recursion (this is the same as that on p662, since
// in this recursive version, it doesn't make sense to copy the string backward)
bool is_palindrome(const char* first, const char* last){
  char back_ch{*last};	// in each call of function, check only 1 char
  // no need to allocate memory in heap by new
  
  // compare those chars
  if(first<last){
    if(back_ch != *first) return false;
    return is_palindrome(first+1, last-1);
  }
  return true;
}


// Ex 10
// We don't know in advance how long the input string might be. So I use (Singly) Linked
// list to make it grow arbitrarily
// The following Single_link class is mainly from Exercise 14 of ch17, but very simplified
// from it, since I no longer need to implement insert() (add the argument before "this")
// and so forth
template<typename T>
class Single_link {
public:
  T content;
  Single_link(const T& c, Single_link* s = nullptr) // s: successor element
    : content{c}, succ{s}
  {}
  ~Single_link(){}
  
  Single_link* next() const {return succ;}
  Single_link* add(Single_link* n);
  const Single_link* advance(int n) const;

private:
  Single_link* succ;
};

// insert n AFTER this Single_link object
template<typename T>
Single_link<T>* Single_link<T>::add(Single_link* n){
  if(n==nullptr)
    return this;
  
  n->succ = succ;
  succ = n;
  return n;
}

// move n positions in list, return nullptr for "not found"
// positive n moves forward, (negative backward move is not done for this version of
// Single_link, unlike Single_link in ch17/exercise/main.cpp)
template<typename T>
const Single_link<T>* Single_link<T>::advance(int n) const {
  if(n <= 0) return this;
  const Single_link* p = this;
  while(n--){
    if(p->succ == nullptr)
      return nullptr;
    p = p->succ;
  }
  return p;
}
istream& read_word(istream& is, char*& buffer){
  // Since I want to change the content of the pointer s in main(), buffer's type must
  // be char** (pointer's pointer) or char*& (reference to a pointer)
  
  // first delete previously held char arrays
  if(buffer)
    delete[] buffer;
  
  int n{0};			// record the word length
  char ch;
  Single_link<char>* head = new Single_link<char>(' ');
  // keeps the pointer to the head element
  Single_link<char>* end = head; // keeps the pointer to the end element

  // to skip any whitespaces in front, first read a char, then put it back
  is >> skipws >> ch;
  // noskipws sticks to cin without explicitly changing cin's state, so I added skipws
  // to return cin's state to skip whitespaces
  is.putback(ch);
  
  // read characters until a whitespace
  while(is >> noskipws >>ch){
    // operator ">>" normally skips whitespace (space, newline, tab, etc)
    // with std::noskipws being after >>, it starts to read whitespaces
    // as well
    if(isspace(ch)) break;

    ++n;
    end->content = ch;
    end = end->add(new Single_link<char>(' '));
    // "end" now points to the new element
  }

  buffer = new char[n+1];	// +1 is for '\0' at last

  // copy the linked list into the allocated char array
  Single_link<char>* p;		// buffer pointer
  for(int i=0; i<n; ++i){
    buffer[i] = head->content;
    p = head;
    head = head->next();
    delete p;
  }
  // now "head" and "end" points to the same, last element
  // still the last element remains (the length of the linked list is n+1, with the last
  // element having empty content), so delete it
  delete head;

  buffer[n] = 0; // == '\0'
  return is;
}


// Ex 11 Skip list
// I don't know if the following implementation of mine is efficient. But I will implement
// what I've  understood now.
template<typename T>
struct Skip_list {
  // T& key(){return k;}
  // Since the return type is a reference, k can be changed through this function, i.e.
  // key() can be lvalue. e.g. this->key() = 3
  // If we do so, there is no need to make k private. So let's just make k public
  //T key; // could be int, could be string, that can be compared by inequality <
  // <- after inserting an element to a skip list, if the key is changed, the order of
  //    the elements can become out of order. So I make key private, and to see the key,
  //    use the following public function.
  const T& get_key(){return key;}
  // By making the return type const reference, it has the same effect as returning
  // the type itself (cannot become lvalue to change key), and unlike returning the
  // type itself, const reference doesn't copy the return value to another temporary
  // variable of type T (that's what happens when the return type is simply T).

  explicit Skip_list(const T& k, bool is_head=false, double p=1/2.0);
  // In creating a Skip_list object, the user needs to provide the pointer to the head
  // (front) element pointer, since the search/insert/delete operations start from
  // the top left part of a skip list, which is the top pointer of the head element.
  // <- I changed this to providing head element pointer at each operation of
  //    insert/delete/search, so that a skip list element can be reused for another
  //    skip list (a different skip list has distinct head element)
  // To avoid implicit conversion like a single int -> Skip_list(int), I attached "explicit"
  // keyword.

  Skip_list* insert(Skip_list& head);
  const Skip_list* search(const Skip_list& head, const T& k) const;
  Skip_list* erase(Skip_list& head);
  // Since when calling these operation functions, we need a Skip_list object to do these
  // operations on, we don't need a pointer/reference to the Skip_list object to
  // insert/erase. But for search operation, we need a key for which the Skip_list object
  // is searching.
  // In every operation, the reference (not pointer, since I do not accept a nullptr) to the 
  // head Skip_list object is needed, because searching in a skip list starts from the 
  // top left corner of it, which is the top level forward_ptr in the head element.

  // display a skip list for debug
  void display(const Skip_list& head);

  // destructor, since each object acquires a dynamically allocated memory by "new"
  // (and its pointer is stored in forward_ptr) like the vector in ch17, 18
  ~Skip_list(){
    delete[] forward_ptr;
  }

  // copy constructor, as we did in Vector class, to avoid issues mentioned in p 632
  Skip_list(const Skip_list& sl)
    : prob{sl.prob}, forward_ptr{new Skip_list*[sl.height]}, height{sl.height},
      max_height{1000}, is_head{sl.is_head}
  {
    // forward_ptr = new Skip_list*[sl.height];
    // height = sl.height;
    // in ch18, these are initialized in the initializer members as above
    for(int i=0; i<sl.height; ++i)
      forward_ptr[i] = sl.forward_ptr[i];
  }
  // For the same reason as copy constructor, define copy assignment
  Skip_list& operator=(const Skip_list& sl){
    // first, since this Skip_list object might already have other member variables,
    // especially allocated memory for forward_ptr, delete it first
    delete[] forward_ptr;

    // Then, the rest is the same as the above copy constructor
    forward_ptr = new Skip_list*[sl.height];
    height = sl.height;
    is_head = sl.is_head;
    // note: in assignment operator, since the Skip_list object on the left (the object
    // to which the right object is copied) already has its own member states, and since
    // max_height is already set to 1000, we don't need max_height = sl.max_height
    for(int i=0; i<sl.height; ++i)
      forward_ptr[i] = sl.forward_ptr[i];
    // In Vector class in ch18, the author uses std::copy() function

    return *this;
    // This return value lets the called function be capable of doing chain process
    // like (Skip_list 1 = Skip_list 2) = Skip_list 3;, as in istream operation
    // overload. I don't know this is appropriate. We can set the return type void.
    // But since the Vector class defined in ch18 has this kind of return type, I'll
    // follow that convention.
  }

  // move constructor, for the case where a Skip_list object that would soon destroyed
  // is copied to another Skip_list object
  Skip_list(const Skip_list&& sl)
    : height{sl.height}, prob{sl.prob}, forward_ptr{sl.forward_ptr}, max_height{1000},
      is_head{sl.is_head}
  {
    /*
    forward_ptr = sl.forward_ptr;
    // 1st, let this object have the allocated memory for the soon-destroyed object
    prob = sl.prob;
    height = sl.height;
    */ // since this is a kind of constructor, we can initialize the members in the
    // above initializer members

    // then, to avoid the moved allocated memory being destroyed in the destructor
    // of the soon-destroyed object, let sl's forward_ptr have a nullptr
    sl.forward_ptr = nullptr;
    sl.height = 0;
  }
  // Move assignment, for the same reason as move constructor
  Skip_list& operator=(const Skip_list&& sl){
    // the content is the same as that of the above move constructor, except that this
    // case has a return value
    forward_ptr = sl.forward_ptr;
    prob = sl.prob;
    height = sl.height;
    is_head = sl.is_head;

    sl.forward_ptr = nullptr;
    sl.height =  0;

    return *this;
  }

private:
  T key; // could be int, could be string, that can be compared by inequality <
  
  double prob;			// probability of promoting another level
  Skip_list<T>** forward_ptr;
  // pointer to point to an array of pointers to Skip_list. The length of this array is
  // determined by
  int height;
  // decided randomly based on prob, except head element. For head elements, this would
  // become maximum (== flipping a coin and all results are heads)
  // For a head element, this later starts to mean the largest index of forward_ptr
  // that points to non-nullptr object in insert()
  
  int max_height;
  // a cap for the height

  bool is_head;
  // to prevent a head to be inserted to another skip list with another head
};

template<typename T>
Skip_list<T>::Skip_list(const T& k, bool is_h, double p)
  // default arguments are in the declaration
  : key{k}, prob{p}, max_height{1000}, height{1}, is_head{is_h}
{
  if(prob<0 || prob>1)
    error("Error in initializing a Skip_list object. The probability must be in [0,1).");
  
  // if the object is head, make the size of this forward_ptr the maximum
  if(is_head){
    height = max_height;
    // then, to make this head object always come before any elements,

    key = numeric_limits<T>::lowest();
    // For the head's key always become the smallest number when comparing other elements
    // But this works only when T is int, float, or double.
    // When T is other types such as string, the minimum key value would be "" (empty
    // string). But when T is a user-defined type, it's impossible to define the "minimum".
    // Maybe 1 solution could be to let the users set the minimum value when the Skip_list
    // object to be instantiated is a head element, by taking the provided argument k
    // as the head value. But in that case, I (builder of this class) have to wish that
    // they don't provide a nonsense value for head elements, and I'm sure that kind of
    // human errors will happen. I don't know how to deal with that for now. So for now,
    // let's stick to this minimum value only.
  }
  else{
    // based on the prob, decide the height (keep flipping the coin with heads coming up with
    // the prob). The height must be at least 1
    random_device rand_dev;
    // random seed for the following random engine. We can define the random engine without
    // this random_device seed, but in that case, invocations of ./main generate
    // the same random number cycle every time. By using this random seed to the random
    // engine, it can generate different random number sequences in each ./main invocation.
    // By the way, the same behavior is observed when I don't use the following random
    // engine, and set the rand_dev in the place of generator in distribution(...).
    // I don't know the difference between them for now.
    // ref: https://stackoverflow.com/questions/21102105/random-double-c11
    static default_random_engine generator(rand_dev());
    // this line should be static. It seems a random number generator should be called
    // only once in a program, and declaring this static does that. Otherwise, each time
    // this constructor is called, the same random number cycle is repeated.
    // We can define this generator without rand_dev(), but in that case, as I wrote in the
    // comment above, the same random number sequence is used every time ./main is invoked.
    // The same random number sequence is used until main.cpp is re-compiled (sometimes,
    // even after re-compilation, ./main uses the same sequence as before the
    // re-compilation)
    uniform_real_distribution<double> distribution(0.0,1.0);
    // random uniform distribution in range [0,1.0) (not includes 1.0)
    double rn{distribution(generator)}; // random number in [0, 1.0)
    while(rn <= prob && height <= max_height){
      height++;
      rn = distribution(generator);
    }
    
  }
  
  forward_ptr = new Skip_list<T>*[height]{nullptr};
  // set all element's pointer to nullptr

  if(is_head)
    height = 1;
  // to avoid searching empty forward_ptr elements in head, I update head's height in
  // insert(). To do so, head's height needs to be 1
}

// display each layer for debug
template<typename T>
void Skip_list<T>::display(const Skip_list& head){
  const Skip_list* p{&head};
  
  for(int i=0; i<head.height; ++i){
    cout << "level " << i << ": head -> ";
    p = head.forward_ptr[i];
    while(p!=nullptr){
      cout << p->key << " -> ";
      p = p->forward_ptr[i];
    }
    cout << "null\n";
  }
}

// insert "this" element after the element with key less than "this" key, but largest among
// elements with key less than "this"
template<typename T>
Skip_list<T>* Skip_list<T>::insert(Skip_list<T>& head){
  // the search for the element with key largest among those with keys smaller than "this"
  // element, is divided into 2 parts. The 1st part is just searching for it, without
  // changing the forward pointers of existing elements. THe 2nd part is searching with
  // changing the forward pointers of existing elements. The 1st part is for when the
  // searcing levels are higher than the height of "this" element, and the 2nd part is for
  // when they are equal to or lower than the height of "this".

  // sanity check
  if(!head.is_head)
    error("Error in Skip_list::isert(). The argument must be a head element of Skip_list class");
  if(this->is_head)
    error("Error in Skip_list::isert(). The object to be inserted (the one for which this function is called) must not be a head element of Skip_list class");
  
  // to not search upper part of forward_ptr of head that just point to nullptr, update
  // the largest index of head's forward_ptr that points to some object.
  // So every time a new element is inserted, check whether to update it.
  head.height = (height > head.height)? height : head.height;
  
  // const Skip_list<T>* p{&head};
  // Note: if I write this without "const", this won't compile, because non-const pointer
  // may change the values pointed to, and head is declared as const.
  // To make it possible to point to a const object and later change the objects to be
  // pointed to by the pointer, use const pointer, since const pointer cannot change
  // the state of the object it points to, but it can change the address it holds.
  // <- later, I removed const from the argument, to update head's height as above.
  Skip_list<T>* p{&head};
  
  // 1st part
  for(int i=head.height-1; i>height-1; --i){ // 0-indexed, so -1 is needed
    // at level i, keep moving forward (toward the end) until finding nullptr
    // or an element with key larget than "this" key
    while(p->forward_ptr[i]!=nullptr && p->forward_ptr[i]->key < key){
      // If p->forward_ptr[i] is nullptr, the while condition breaks at this 1st condition.
      // So the 2nd condition is not executed, thus we need not worry about trying to
      // access key of nullptr
      p = p->forward_ptr[i];
    }
  }

  // 2nd part
  for(int i=height-1; i>-1; --i){ // 0-indexed, so -1 is needed
    // this while-loop is the same as the one in the 1st part
    while(p->forward_ptr[i]!=nullptr && p->forward_ptr[i]->key < key){
      p = p->forward_ptr[i];
    }
    // p now points to the element right before the position into which "this" is to be
    // inserted.
    // Then, update the forward_ptr of "this" element and the element before "this"
    // element at this level
    forward_ptr[i] = p->forward_ptr[i];
    p->forward_ptr[i] = this;
  }
  
  return this;
  // The type of this in a member function of class X is X* (pointer to X)
  // https://en.cppreference.com/w/cpp/language/this
  // So const is not attached to this.
  // But as in p620, the compiler ensures that the value in this does not change.
}

// search for the element with key equal to the provided argument k, or larget among
// keys less than k.
// The content is almost the same as the 1st part of Skip_list<T>::insert() except the
// indexing and the inequality (< changes to <= to include the key equal to k)
template<typename T>
const Skip_list<T>* Skip_list<T>::search(const Skip_list& head, const T& k) const{
  // Once const is attached to the argument type, it sticks throughout this function,
  // and outside of this function, unless we strip const away by const_cast<Skip_list<T>*>.

  // Since search() operation doesn't change any internal states of searched objects, I
  // don't do sanity check in this function, unlike insert()
  
  const Skip_list* p{&head};

  for(int i=head.height-1; i>-1; --i){
    while(p->forward_ptr[i]!=nullptr && p->forward_ptr[i]->key <= k){
      p = p->forward_ptr[i];
    }
  }
  return p;
}

// remove "this" object from the skip list of the provided head
template<typename T>
Skip_list<T>* Skip_list<T>::erase(Skip_list& head){
  // Once const is attached to the argument type, it sticks throughout this function,
  // and outside of this function, unless we strip const away by const_cast<Skip_list<T>*>.
  // In erase(), I want to change the states of Skip_list objects pointed to by the
  // folloiwng pointer (changing the forward_ptr), so I didn't use const argument
  // in the first place.

  // Since this operation deals with the case where it cannot find the "this" object in
  // this skip list inside the folloiwng for-loop, in this function either, I don't have
  // to do sanity check, unlike insert()
  
  Skip_list* p{&head};
  for(int i=this->height-1; i>-1; --i){ // start searching for "this" object from its height
    while(p->forward_ptr[i] != this && p->forward_ptr[i] != nullptr){
      p = p->forward_ptr[i];
    }
    // since the search for "this" object starts from "this" object's height, the above
    // search must find "this" object at level i. If it cannot find it, that's an error.
    if(p->forward_ptr[i] == nullptr){
      error("In Skip_list::erase(), cannot find the element in this skip list of the provided head.");
    }
    p->forward_ptr[i] = this->forward_ptr[i];
    this->forward_ptr[i] = nullptr; // disconnect "this" object at level i
  }

  return this;
}


// Ex 12
// Before ex 12, I'll test if the content of arrays whose size is fixed and that is not 
// allocated on heap memory is also copied when copying a class object
struct A {
  int a[10];
  // the size is fixed and not obtained by "new" operator, so this array should reside in
  // stack storage (if A object is created in a function)
  A(int k){
    for(int i=0; i<10; ++i)
      a[i] = k;
  }
  void show(){
    for(int i=0; i<10; ++i)
      cout << a[i] << " ";
    cout << endl;
  }
};
// I checked that the array contents are copied.

// Command class is used for reading commands by a player of Hunt the Wumpus game, such as
// "s13-4-3".
// I first place Command class inside HW_game class's private section, but if I do so, in the
// operator overload of >>, I cannot specify Command class as its 2nd argument. Probably I can
// still place Command class inside HW_game class's public section, and call it in the 2nd
// argument of >>, but I'd rather choose to place it outside of HW_game class.
struct Command{		// e.g. s13-4-3
    char move;			// either 's' (shoot) or 'm' (move)
    int room_nums[3];		// At most 3 room numbers are specified
    // In 'm', room_nums[0] is the next room to move to
    // In 's', room_nums[0,1,2] specifies the rooms the arrow moves along
    // If illegal room numbers are specified in 's', they are replaced with random valid
    // (adjacent) room numbers.
};
// By the way, if I put this operator overload inside Command class, since the member functions'
// 1st argument always become "this" keyword (the Command class object that calls the member
// functions), if I want to set Command class to their 2nd argument, I cannot define it as a
// member function
istream& operator>>(istream& is, Command &cmd){
  // to deal with different lengths of inputs (e.g. s13-4-3, m12), I first get the whole line,
  // because if I don't do so, this operator waits for the next character indefinitely when
  // the player will not write any more command (e.g. s13-4 is a possible command, but since
  // one more room number is also possible, command line stops at s13-4)
  string line;
  getline(is, line);

  // Before putting a new command to cmd, delete the old command
  cmd.move = 'e';
  cmd.room_nums[0] = -1, cmd.room_nums[1] = -1, cmd.room_nums[2] = -1;
  
  // Then, use istringstream
  istringstream istr{line};
  char a;
  int rms[3]={-1, -1, -1};	// -1 means no room is specified
  istr >> a;
  if(a != 'm' && a != 's'){
    is.clear(ios_base::failbit); // set the state to fail()
    return is;
  }

  // if the action is shoot, we take at most 3 destinations
  if(a == 's'){
    // "12-11-13" or "12" or "12-11"
    int r;
    char sep;			// separator '-'
    for(int i=0; i<3; ++i){
      if(istr >> r){
	rms[i] = r;
      }
      else{
	is.clear(ios_base::failbit);
	return is;
      }

      // check if there is no character after the 3rd int
      if(i == 2 && !istr.eof()){
	char buff;	     // buffer char to flush any remaining white spaces in the last
	istr >> buff;
	// Even after reading 1 character, if istr's state is not in end-of-file, that means
	// there are some character after the 3rd int other than a whitespace
	if(!istr.eof()){
	  cout << "Maximum arror range is 3\n";
	  is.clear(ios_base::failbit);
	  return is;
	}
      }

      if(istr.eof())
	break;

      istr >> sep;
      if(sep != '-'){
	cout << "Arrow direction separator must be '-'\n";
	is.clear(ios_base::failbit);
	return is;
      }
    }

    cmd.room_nums[0] = rms[0];
    cmd.room_nums[1] = rms[1];	// might be -1
    cmd.room_nums[2] = rms[2];
  }
  else{				// if the action is move, take only 1 int
    int r;
    char buff;			// buffer char to flush any remaining white spaces in the last
    if(istr >> r){
      rms[0] = r;
    }
    else{
      is.clear(ios_base::failbit);
      return is;
    }

    // In case there is some whitespaces in the end, we read 1 char
    // (if I don't do this, in such a case, istr does not become end-of-file state)
    istr >> buff;		// this buff is used nothing
    // Even if buff reads 1 char, and that 1 char is the last element in istr, istr doesn't
    // become end-of-file state. But if buff is in string class, istr does. This is 1 slight
    // difference between reading in string or char variable.
    // E.g. "m12 1", then, if buff is in char, it reads '1', but istr's state has not yet been
    //      in end-of-file state. But if buff is in string, it reads "1", along with setting
    //      istr to end-of-file state.
    
    if(!istr.eof()){
      cout << "When the action is \"Move\", you can specify only 1 room number.\n";
      is.clear(ios_base::failbit);
      return is;
    }

    cmd.room_nums[0] = rms[0];
    cmd.room_nums[1] = -1;
    cmd.room_nums[2] = -1;
  }

  cmd.move = a;
  return is;			// reaching here means the reading succeeded
}

ostream& operator<<(ostream& os, Command &cmd){
  cout << "Command char: " << cmd.move << ", " << "cmd.room_nums[0,1,2] = " << cmd.room_nums[0]
       << ", " << cmd.room_nums[1] << ", " << cmd.room_nums[2] << endl;
  return os;
}
// ===========================================================================================

struct Cave {
  Cave();
  void print();
  // print the state of the Cave, mainly for debug

  int put_player_initial();
  // put the player to the Cave for its initial position. Avoid rooms with Wumpus, Pits, and
  // Bats. The pits and bats can be avoided by using index_perm in this class

  void adjacent_rooms(int rn, int (&adj_rms)[3]){
    // This is how we use a reference to an array. But using vector is better.
    if(rn<1 || rn>20)
      error("Error in Cave::adjacent_rooms(int). The argument int must be in [1,20]");
    adj_rms[0] = rooms[rn].t1, adj_rms[1] = rooms[rn].t2, adj_rms[2] = rooms[rn].t3;
    // I first used tuple, but since tuple cannot be accessed by using index variable i
    // (e.g. int i=0; get<i>(adj_rms) generates an error), I switched to using a reference
  }
  // print signs of dangers in adjacent rooms
  void notify_dangers(int rn);

  // Moves the player according to the destination
  int move_player(int move_dest);  

  int wumpus_startled(bool is_player=true);
  // It is called when a player enters the room with the Wumpus. The Wumpus is startled by the
  // entrance, and with 50% of chance, it either stays in the same room or moves to an adjacent
  // room.
  // Later I made this member public, because I want to call this from HW_game class (in
  // HW_game::play(), where an arrow shooting is processed)

  bool shoot_a_room(int shot_rn);

  int clear();
  // Reset the condition of the cave, i.e. shuffle index_perm again, and assign pits, bats,
  // and the Wumpus again.
private:
  struct Room {
    int t1,t2,t3;
    // indices to the rooms to which this Room is connected via the 3 tunnels
    bool bat, player, wumpus, pit;
    // indicators of these are in this Room
    Room()
      : t1{}, t2{}, t3{}
    {}
  };
  Room rooms[21];
  // the # of Rooms in a cave is pre-set to 20, from the original Hunt the Wumpus
  // To make the indices 1-indexed, I prepare 21 Rooms
  // I make Room definition and rooms private, to avoid accidental change in cave states,
  // especially the room connections, because they are supposed to be fixed

  int index_perm[20];		// a random permutation of 20 (from 1 to 20, not from 0) indices
  // used for setting room #s to bat, pit, wumpus, and the player, avoiding picking up the same
  // room # as those rooms with bat, pit (the Wumpus can be in the same room as bat or pit)
  // for the initial setting

  int bat_rn[2];		// 2 giant bats' room #s, fixed
  int pit_rn[2];		// 2 bottomless pits' room #s, fixed
  int wumpus_rn;		// the Wumpus' room #, can change
  int player_rn;		// the player's room #, can change
  // Cave class doesn't have to store the position of the player. There is no member function
  // to use that information for its process. In put_player_initial() and move_player(int),
  // they store player_rn, but in those members, player_rn is used only for lvalue, not
  // rvalue, which means those members doesn't use the information of player_rn for its
  // processes. So we can cut this variable, and modify those 2 functions not to store
  // player_rn. But for now, this is just a small piece, so I leave it.

  int bat_replacement();
  // It is called when a player enters the room with a bat. It returns a random room number
  // except the room numbers where bats exist.
};
Cave::Cave(){
  // Which Room is connected to which is already decided. The structure is from the original
  // Hunt the Wumpus. Since there seems no regular pattern in the connection, I set them
  // manually.
  // Note that the indexing is 1-indexed.
  rooms[1].t1 = 2, rooms[1].t2 = 5, rooms[1].t3 = 8;
  rooms[2].t1 = 1, rooms[2].t2 = 3, rooms[2].t3 = 10;
  rooms[3].t1 = 2, rooms[3].t2 = 4, rooms[3].t3 = 12;
  rooms[4].t1 =3, rooms[4].t2 = 5, rooms[4].t3 =14;
  rooms[5].t1 = 1, rooms[5].t2 = 4, rooms[5].t3 = 6;
  rooms[6].t1 = 5, rooms[6].t2 = 7, rooms[6].t3 = 15;
  rooms[7].t1 = 6, rooms[7].t2 = 8, rooms[7].t3 = 17;
  rooms[8].t1 = 1, rooms[8].t2 = 7, rooms[8].t3 = 9;
  rooms[9].t1 = 8, rooms[9].t2 = 10, rooms[9].t3 = 18;
  rooms[10].t1 = 2, rooms[10].t2 = 9, rooms[10].t3 = 11;
  rooms[11].t1 = 10, rooms[11].t2 = 12, rooms[11].t3 = 19;
  rooms[12].t1 = 3, rooms[12].t2 = 11, rooms[12].t3 = 13;
  rooms[13].t1 = 12, rooms[13].t2 = 14, rooms[13].t3 = 20;
  rooms[14].t1 = 4, rooms[14].t2 = 13, rooms[14].t3 = 15;
  rooms[15].t1 = 6, rooms[15].t2 = 14, rooms[15].t3 = 16;
  rooms[16].t1 = 15, rooms[16].t2 = 17, rooms[16].t3 = 20;
  rooms[17].t1 = 7, rooms[17].t2 = 16, rooms[17].t3 = 18;
  rooms[18].t1 = 9, rooms[18].t2 = 17, rooms[18].t3 = 19;
  rooms[19].t1 = 11, rooms[19].t2 = 18, rooms[19].t3 = 20;
  rooms[20].t1 = 13, rooms[20].t2 = 16, rooms[20].t3 = 19;

  // For randomly picking up random indices without repetition, set a random permutation of
  // room indices (from 1 to 20)
  for(int i=1; i<21; ++i)
    index_perm[i-1] = i;
  // Be careful on the indexing of index_perm. index_perm[20] has only 20 elements, but the
  // i starts with 1. So be sure to adjust the indexing by subtracting 1. Otherwise, it accesses
  // index_perm[20], which is unknown value, and leaves index_perm[0] uninitialized. And if
  // we proceed with that unknown index_perm[0] value (e.g. 69857296), it can cause illegal
  // access error (segmentation fault) in the later processes
  
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  shuffle(index_perm, index_perm+20, default_random_engine(seed));
  // shuffle the array uniformly randomly
  // Although the final element's address is index_perm+19, here index_perm+20 is used, because 
  // std::shuffle()'s range is [first, last) == [first, last-1].
  // Note: random_shuffle() is deprecated (= in later versions of C++, random_shuffle() it
  //       to be removed), so we shouldn't use it. Instead, use shuffle().
  // This piece of code is from https://www.cplusplus.com/reference/algorithm/shuffle/
  
  // Then, randomly set 2 giant bats, 2 bottomless pits, and 1 Wumpus
  // (player is not set in this class, he is set at HW_game class)
  // for 2 bats
  bat_rn[0] = index_perm[0];	// index_perm[0] is for the 1st super bat
  bat_rn[1] = index_perm[1];
  // Since index_perm is a permutation, we need not worry about the overlap of the room #s

  // for 2 pits
  pit_rn[0] = index_perm[2];
  pit_rn[1] = index_perm[3];

  // Wumpus, on the other hand, doesn't care about bats or pits, so it can overlap
  wumpus_rn = rand_int(1,20);
  // Don't attach "int" in front, of course. If doing so, a new local variable with the same
  // name as the one in this class's private section is made, and that local change doesn't
  // stick to the class member.
}

// reset the cave condition
int Cave::clear(){
  // the code in this function is directly from the constructor above
  
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  shuffle(index_perm, index_perm+20, default_random_engine(seed));

  // for 2 bats
  bat_rn[0] = index_perm[0];	// index_perm[0] is for the 1st super bat
  bat_rn[1] = index_perm[1];

  // for 2 pits
  pit_rn[0] = index_perm[2];
  pit_rn[1] = index_perm[3];

  // Wumpus, on the other hand, doesn't care about bats or pits, so it can overlap
  wumpus_rn = rand_int(1,20);

  player_rn = put_player_initial();
  return player_rn;
}

void Cave::notify_dangers(int rn){
  if(rn<1 || rn>20)
    error("Error in Cave::notify_dangers(int). The argument int must be in [1,20]");

  int adj_rms[3];
  adjacent_rooms(rn, adj_rms);
  int adj_rn;
  for(int i=0; i<3; ++i){
    adj_rn = adj_rms[i];

    if(adj_rn == bat_rn[0] || adj_rn == bat_rn[1])
      cout << "\t I hear a bat\n";

    if(adj_rn == pit_rn[0] || adj_rn == pit_rn[1])
      cout << "\t I feel a breeze\n";

    if(adj_rn == wumpus_rn)
      cout << "\t I smell the wumpus\n";
  }
}

// print the state of the Cave
void Cave::print(){
  // I gave up printing the structure of the cave, since it's too much work, and little
  // return
  // Instead, I will just print where the bats, pits, and Wumpus are
  // The player's position is always printed at each turn.
  cout << "The bottomless pits are at Room " << pit_rn[0] << " and " << pit_rn[1] << endl;
  cout << "The giant bats are at Room " << bat_rn[0] << " and " << bat_rn[1] << endl;
  cout << "The Wumpus is at Room " << wumpus_rn << endl;
}

int Cave::put_player_initial(){
  player_rn = index_perm[4];
  // check if this is not overlapped with the Wumpus (it is guaranteed that this is not
  // overlapped with pits or bats by using index_perm[4])
  int i=4;
  if(player_rn == wumpus_rn)
    player_rn = index_perm[5];

  rooms[player_rn].player = true;
  return player_rn;
}

int Cave::move_player(int move_dest){
  if(move_dest < 1 || move_dest > 20)
    error("Error in Cave::move_player(), invalid destination is used");

  // First, check if there is a pit in the destination, because if a pit exists, that results
  // in the player's death instantly
  // (Even if the Wumpus is in the room, it may move to an adjacent room witn 50 % chance, so
  //  So the Wumpus existing in the destination room doesn't necessarily mean the player's
  //  death)
  if(move_dest == pit_rn[0] || move_dest == pit_rn[1]){
    cout << "\tThe player fell into a pit!\n";
    player_rn = -1;		// room -1 means the player is dead
    return -1;
  }

  // Second, check the Wumpus, bacause even if a bat and the Wumpus co-exist in the destination
  // room, if the Wumpus happens to stay in the room, the player is killed, which supercedes
  // a bat's replacement of the player
  if(move_dest == wumpus_rn){
    wumpus_rn = wumpus_startled();
    // if, even after the Wumpus is startled by the player, it stays in the same room, the
    // player is killed by it
    if(wumpus_rn == move_dest){
      cout << "\tThe Wumpus is in the room!\n";
      player_rn = -1;
      return -1;
    }
    else{
      // Do nothing.
      // Since we still need to check if a bat exists in the same room, we cannot return
      // the function here
    }
  }

  // Lastly, check if a bat is in the destination. If so, it would carry the player to a random
  // room except the current room or the room with another bat (bats keep staying in the same
  // rooms)
  if(move_dest == bat_rn[0] || move_dest == bat_rn[1]){
    int new_dest{bat_replacement()};
    cout << "\tA giant bat has carried you to Room " << new_dest << "!\n";
    player_rn = move_player(new_dest);
    // If in the new destination, a pit and/or the Wumpus exist, we have to repeat the same
    // checking process for the new destination. So move_player() is recursively called here.
    return player_rn;
  }

  // if no threat exists in the destination room, set player_rn to the destination finally
  player_rn = move_dest;
  return player_rn;
}

int Cave::wumpus_startled(bool is_player){
  // There are 2 types of the Wumpus being startled, 1st is by the player entering the Room
  // the Wumpus is in, and 2nd is by the player shooting an arrow moving across Rooms.
  // In the former case, the probability of the Wumpus moving to an adjacent Room is 50 %,
  // but in the latter case, it moves to an adjacent Room for sure (100 %).
  // The default value of "is_player" is true.

  if(wumpus_rn < 0){
    return wumpus_rn;		// if the Wumpus has been already hunted, just return the
    // same Room #, which is -1.
  }
  
  if(is_player){
    // 1st create a uniformly random number in [0,1.0)
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    default_random_engine gen(seed);
    uniform_real_distribution<double> distribution(0.0,1.0);
    double rn{distribution(gen)};
    
    if(rn < 0.5){
      int adj_rms[3];
      adjacent_rooms(wumpus_rn, adj_rms);
      double rn2{distribution(gen)}; // generate a 2nd uniformly random number in [0, 1.0)
      if(rn2<(1.0/3)) wumpus_rn = adj_rms[0];
      else if(rn2<(2.0/3)) wumpus_rn = adj_rms[1];
      else wumpus_rn = adj_rms[2];
    }
    else{				// stay in the same room 
      // do nothing
    }
  }
  else{				// the case where the arrow startled the Wumpus
    int adj_rms[3];
    adjacent_rooms(wumpus_rn, adj_rms);
    wumpus_rn = adj_rms[rand_int(0,2)];
  }

  return wumpus_rn;
}

int Cave::bat_replacement(){
  return index_perm[rand_int(2,20)];
  // index_perm[0,1] are the Room #s for the 2 giant bats. A bat moves the player randomly
  // to a Room without a bat, so choose the index from 2 to 20, inclusive.
  // (rand_int(min, max) generates a random number in [min, max], including min and max)

  // We can include index_perm[0,1] for the bats to choose a room with a bat as well.
  // If I change the code that way, Cave::move_player() works correctly, because in the
  // if-sentence for bat checking, it calls itself recursively.
}

bool Cave::shoot_a_room(int shot_rn){
  if(shot_rn < 1 || shot_rn > 20)
    error("Error in Cave::shoot_a_room(int). The room # must be in [1,20]");

  if(wumpus_rn == shot_rn){
    wumpus_rn = -1;		// Room -1 means the Wumpus has been hunted.
    return true;
  }
  return false;
}

// =========================================================================================

struct HW_game {
  void play(bool is_debug=false);
  // play one run of Hunt the Wumpus game (until a player wins or loses), and repeat it
  // as long as the player wishes.
  // If is_debug is true, after every move of the player, print the cave's condition.

  void run();
  // repeat play()
  
  HW_game()
    : cave{}, player_rn{cave.put_player_initial()}
  {
    // By the empty constructor of Cave class, at this point, in variable cave, the Wumpus,
    // 2 bats, and 2 pits are already set.
    // In addition, the player is also set to its initial position by cave.put_player_initial().
    // The function deals with overlap between the player and Wumpus.
  }
private:
  bool is_valid_move(Command cmd);
  // check if the destination of the move 'm' is correct

  bool shoot_rooms(Command cmd);
  
  Cave cave;
  int player_rn;
};

void HW_game::run(){
  char r;
  char m;
  string buff;		// buffer
  while(true){
    cout << "Do you play Hunt the Wumpus? (y/n) ";
    cin >> r;
    if(r == 'y'){
      cout << "In debug mode, or normal mode? (d/n) ";
      cin >> m;
      if(m == 'd'){
	getline(cin, buff);
	// Without getline(), the first read of Command in play() failed. I don't exactly know
	// why
	this->play(true);	// "this->" is not necessary, but for clarification
      }
      else if(m == 'n'){
	getline(cin, buff);
	this->play(false);
      }
      else
	cout << "Unknown mode is entered. Mode is 'd' or 'n'.\n";
    }
    else if(r == 'n')
      break;
    else
      cout << "Sorry, can you answer either 'y' or 'n'?\n";
  }
}

bool HW_game::is_valid_move(Command cmd){
  // If the move is shoot, always return true regardless of the destination of the shoot
  if(cmd.move == 's')
    return true;
  
  int adj_rms[3];
  cave.adjacent_rooms(player_rn, adj_rms);
  for(int i=0; i<3; ++i){
    if(adj_rms[i] == cmd.room_nums[0])
      return true;
  }
  return false;
}

bool HW_game::shoot_rooms(Command cmd){
  int current_rn{player_rn};
  int adj_rms[3];
  bool HUNTED_WUMPUS{false};
  int shot_rms[3] = {-1,-1,-1};		// for printing which rooms are actually shot
  
  for(int i=0; i<3; ++i){
    cave.adjacent_rooms(current_rn, adj_rms);

    // It's possible that the player enters only 1 or 2 room(s), e.g. s13. In that case,
    // cmd.room_nums[1,2] == -1. So break the loop once -1 is detected.
    if(cmd.room_nums[i] == -1)
      break;
    
    // check if the destination of the arrow is included in the adjacent rooms
    if(cmd.room_nums[i] == adj_rms[0] || cmd.room_nums[i] == adj_rms[1] ||
       cmd.room_nums[i] == adj_rms[2]){
      // Before checking if the Wumpus is hunted by the arrow, check if the arrow comes to
      // the player's own room. In that case, the player is killed by his own arrow, according
      // to Wikipedia
      if(cmd.room_nums[i]==player_rn){
	cout << "\tThe arrow came to your own Room, and you are killed by your own arrow...\n";
	player_rn = -1;
	return false;
      }
      HUNTED_WUMPUS = cave.shoot_a_room(cmd.room_nums[i]);
      current_rn = cmd.room_nums[i];
      shot_rms[i] = current_rn;
      if(HUNTED_WUMPUS)
	break;
    }
    else{
      // If the arrow destination is not a valid adjacent room #, set a random yet valid
      // (adjacent) room #
      current_rn = adj_rms[rand_int(0,2)];

      if(current_rn==player_rn){
	cout << "\tThe arrow came to your own Room, and you are killed by your own arrow...\n";
	player_rn = -1;
	return false;
      }
      
      HUNTED_WUMPUS = cave.shoot_a_room(current_rn);
      shot_rms[i] = current_rn;
      if(HUNTED_WUMPUS)
	break;
    }
  }

  // print which room(s) are shot
  cout << "\tRoom ";
  for(int i=0; i<3; ++i){
    if(shot_rms[i]==-1){
      // Since shot_rms[0] cannot be -1, i coming this if-sentence is either 1 or 2
      if(i==1) cout << " is";
      else cout << " are";	// if i==2
      break;
    }
    if(i==0) cout << shot_rms[i];
    else if(i==1) cout << ", " << shot_rms[i];
    else cout << ", and " << shot_rms[i] << " are";
  }
  cout << " shot by the magical arrow\n";
  
  return HUNTED_WUMPUS;
}

void HW_game::play(bool is_debug){
  // First, initialize the cave condition
  player_rn = cave.clear();
  // This process is redundant if this HW_game::play() is called for the first time after
  // the HW_game instance is made (because the initialization of the cave is already done
  // in the beginning of the HW_game's constructor)
  
  bool WUMPUS_HUNTED{false};
  // becomes true when the Wumpus is hunted

  int num_arrows{5};
  // The number of arrow the player can shoot is not mentioned either on the book or on
  // Wikipedia. But to make the game a little realistic and fun, I set a maximum number
  // of arrows. If the player runs out of all arrows, he loses.
  
  cout << "For the map of the cave, please see https://en.wikipedia.org/wiki/Hunt_the_Wumpus#/media/File:Hunt_the_Wumpus_map.svg\n";
  
  Command cmd;			// Command class is defined above
  int adj_rms[3];
  while(true){
    // first print where the player is, regardless of whether it is debug mode or not
    cout << "The player is at Room " << player_rn << ", and you have " << num_arrows
	 << " arrows." <<endl;
    cave.adjacent_rooms(player_rn, adj_rms);
    cout << "Tunnels lead to Room " << adj_rms[0] << ", " << adj_rms[1]
	 << ", and " << adj_rms[2] << endl;
    
    if(is_debug)
      cave.print();		// print where all the other entities are in the cave

    cave.notify_dangers(player_rn);

    // keep reading a command until the player input a valid command
    while(true){
      cout << "Move or shoot? ";
      if(cin >> cmd && is_valid_move(cmd))		// e.g. s13-4-3
	// here also checks if the destination of move 'm' is a valid neighbor, if cmd.move is
	// 'm'.
	// I don't care if in shoot 's', the destination rooms are valid or not, because
	// if they are invalid, the game picks up a valid option at random, according to
	// the wikipedia of this game (https://en.wikipedia.org/wiki/Hunt_the_Wumpus)
	break;
      else{
	cout << "An invalid command is entered. Examples are: m12, s12-3-4, s1-2\n";
	cout << "If command 'm' is entered, valid options are Room " << adj_rms[0] << ", "
	     << adj_rms[1] << ", " << adj_rms[2] << endl;;
	cout << "Enter another command again\n";
	cin.clear();
	// reset the fail state. Without this, cin >> cmd fails again without reading a new
	// command, which results in an infinite loop where those error outputs are infinitely
	// written.
      }
    }

    if(cmd.move == 'm'){
      // In the input process above, I already checked if the destination of the move 'm' is
      // valid in is_valid_move(cmd)
      player_rn = cave.move_player(cmd.room_nums[0]);
    }
    else{			// cmd is shoot 's'
      WUMPUS_HUNTED = shoot_rooms(cmd);
      // According to Wikipedia's gameplay explanation, every time after an arrow is shot,
      // the Wumpus is startled, and moves to an adjacent room

      num_arrows--;
      
      int wumpus_rn;
      wumpus_rn = cave.wumpus_startled(false);

      // As a result of the Wumpus moving after the shoot, if the Wumpus comes to the player's
      // Room, the player is killed
      if(wumpus_rn == player_rn){
	cout << "\tOuch! Your arrow startled the Wumpus, and it has entered your room...\n";
	player_rn = -1;
      }
    }

    if(player_rn < 0){
      // This means the player is dead, either by a pit or the Wunpus
      cout << "\tYou are dead!\n";
      break;
    }

    if(WUMPUS_HUNTED){
      cout << "\tCongratulation! You successfully hunted the Wumpus!\n";
      break;
    }

    // The checking of the number of arrows should come after the checking of whether the Wumpus
    // was hunted or not, because even when the number of arrows becomes 0, it's possible that
    // the last arrow hunted the Wumpus.
    if(num_arrows<1){
      cout << "\tYou ran out of arrows. There is no hope to hunt the Wumpus anymore...\n";
      cout << "\tYou lost.\n";
      break;
    }

    cout << endl;
  }
}

int main()
  try{
    // Ex 1
    /*
    const char* test_str = "test";
    // const is needed since this string cannot be changed later (if we try to do it,
    // it causes undefined behavior)
    // https://stackoverflow.com/questions/20944784/
    cout << test_str << endl;
    char* p1 = strdup(test_str);
    cout << p1 << endl;
    */

    // Ex 2
    /*
    const char* s = "ttaddaetststtest";
    const char* x = "test";
    int lenx = char_func::strlen(x);
    const char* p = findx(s,x);
    if(p){			// if p is not nullptr
      for(int i=0; i<lenx; ++i)
	cout << *(p+i);
      cout << endl;
    }
    */

    // Ex 3
    //cout << ('A' < 'a') << endl; // test if characters can be compared lexicographically
    // 'A' == 65, 'a' == 97 in ASCII code, so character comparison is in fact to compare
    // these ASCII code integers
    /*
    const char* s1 = "test";
    const char* s2 = "test!!!";
    int check = strcmp(s1, s2);
    if(check < 0) cout << "s1 is lexicographically before x2\n";
    else if(check > 0) cout << "s1 is lexicographically after x2\n";
    else
      cout << "s1 is lexicographically equal to x2\n";
    */


    // Ex 4
    /*
    const char s1[4] = {'t', 'e', 's', 't'}; // non-zero terminated string stored in stack
    const char* s2 = new char[9] {'t', 'e', 's', 't', 'a', 'm', 'e', 'n', 't'};
    // non-zero terminated string stored in heap (free) memory
    //cout << s1[4] << endl;	// check no 0 is stored at the end
    // This generates a warning, but I can compile this
    //cout << s2[4] << endl;
    const char* s3 = "testtest";
    //cout << s3[4] << endl;	// as a comparison to 0-terminated (C-stryle) string
    // all of the output became empty, so I guess the end already is set to 0

    // testing strdup()
    char* p1;
    char* p2;
    p1 = char_func::strdup(s1);
    p2 = char_func::strdup(s2);
    cout << p1 << endl;
    cout << p2 << endl;
    
    // testing findx()
    const char* p;
    p = char_func::findx(s1, s2);
    int lens2 = char_func::strlen(s2);
    if(p){			// if p is not nullptr
      for(int i=0; i<lens2; ++i)
	cout << *(p+i);
      cout << endl;
    }

    // testing strcmp()
    int check = char_func::strcmp(s1, s2);
    if(check < 0) cout << "s1 is lexicographically before x2\n";
    else if(check > 0) cout << "s1 is lexicographically after x2\n";
    else
      cout << "s1 is lexicographically equal to x2\n";

    // All the 3 testing works fine for s1 and s2
    // Since I didn't attach debug option (-g) to my compilation command in the 1st place,
    // these results seem to be the results without debug mode

    // after adding another argument giving the max number of elements to the 3 functions
    // (the function that works as checking the max length is actually strlen())
    p1 = char_func::strdup(s1);
    p2 = char_func::strdup(s2);
    char* p3;
    p3 = char_func::strdup(s3);
    cout << p1 << endl;
    cout << p2 << endl;
    cout << p3 << endl;
    
    // testing findx()
    p = char_func::findx(s2, s1);
    int lens1 = char_func::strlen(s1);
    if(p){			// if p is not nullptr
      for(int i=0; i<lens1; ++i)
	cout << *(p+i);
      cout << endl;
    }

    // testing strcmp()
    check = char_func::strcmp(s1, s2);
    if(check < 0) cout << "s1 is lexicographically before x2\n";
    else if(check > 0) cout << "s1 is lexicographically after x2\n";
    else
      cout << "s1 is lexicographically equal to x2\n";

    // After adding the additional argument max_num as well, these worked as well as
    // before adding the argument, for both a C-style string and "bad" strings
    */


    // Ex 8
    // for string argument
    // for(string s; cin>>s;){
    //   cout << s << " is";
    //   if(!is_palindrome(s)) cout << " not";
    //   cout << " a palindrome\n";
    // }
    // tested the function with string works

    // using arrays
    // constexpr int max{128};
    // for(char s[max]; read_word(cin, s, max);){
    //   //cout << "s's size == " << char_func::strlen(s) << endl;
    //   cout << s << " is";
    //   if(!is_palindrome(s,char_func::strlen(s))) cout << " not";
    //   cout << " a palindrome\n";
    // }
    // tested the function with array works

    // using pointers 1
    // constexpr int max{128};
    // for(char s[max]; read_word(cin, s, max);){
    //   cout << s << " is";
    //   if(!is_palindrome(s)) cout << " not";
    //   cout << " a palindrome\n";
    // }
    // tested the function with pointers 1 works
    
    // using pointers 2
    // constexpr int max{128};
    // for(char s[max]; read_word(cin, s, max);){
    //   cout << s << " is";
    //   if(!is_palindrome(s, &s[char_func::strlen(s)-1])) cout << " not";
    //   cout << " a palindrome\n";
    // }
    // tested the function with pointers 2 works

    // Ex 10
    // I think what we should change for accepting an arbitrarily long stringis not
    // is_palindrome(), but how we read characters.
    /*
    int n;			// read string length
    constexpr int upper_lim{1000};
    for(char* s=nullptr; read_word(cin, s);){
      n = char_func::strlen(s);
      if(n > upper_lim)
	cout << "The input string is too long (> " << upper_lim <<" characters)\n";
      cout << s << " is";
      if(!is_palindrome(s,char_func::strlen(s))) cout << " not";
      cout << " a palindrome\n";
    }
    */
    // I made another version of read_word(), and changed the array version to read
    // an arbitrary long string (for (b)). For (a), I just added the if-condition in
    // the for-loop above to print that the input string is too long.
    // So the complexity of (a) and (b) is simply coming down to (b)'s complexity.
    // (a) cannot even be said as "another version". It's just letting the user know
    // the string is very long. I probably misunderstand the question, but I don't know
    // how to interpret (a) other than this way.
    // I don't change is_palindrome(). I changed only read_word() using singly-linked list. 
    // My read_word()'s complexity (in big-O) is O(n), where n is the length of an input
    // string


    // Ex 11
    /*
    Skip_list<int> head(0, true);
    Skip_list<int> sl3(7);
    sl3.insert(head);
    Skip_list<int> sl1(3);
    sl1.insert(head);
    Skip_list<int> sl2(6);
    sl2.insert(head);
    Skip_list<int> sl6(19);
    sl6.insert(head);
    Skip_list<int> sl4(9);
    sl4.insert(head);
    Skip_list<int> sl5(12);
    sl5.insert(head);

    const Skip_list<int>* p;
    p = sl4.search(head, 6);
    cout << p->key << endl;

    sl5.erase(head);
    
    head.display(head);
    */


    // Ex 12
    // Before the exercise, I'll check if an array's contents in a class object are also
    // copied when the array is obtained with some fixed size, without using "new" operator
    // (so they resides in local stack storage, not in heap storage)
    // A a1(12);
    // A a2(a1);
    // a1.show();
    // a2.show();
    // I checked that the array contents are copied.
    // So, the copy constructor or copy assignment are needed only when some memory is
    // dynamically allocated on heap storage, as in the Vector class in ch18.

    // check std::random_shuffle() to see if this can create a random permutation
    // int a[10]={1,2,3,4,5,6,7,8,9,10};
    // unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    // shuffle(a, a+10, default_random_engine(seed));
    // // Although the final element's address is a+9, here a+10 is used, because std::shuffle()
    // // 's range is [first, last) == [first, last-1].
    // cout << "a = ";
    // for(int i=0; i<10; i++)
    //   cout << a[i] << " ";
    // cout << endl;

    // check how istringstream works
    // istringstream isr{"test test"};
    // string s;
    // isr >> s;
    // if(isr.eof())
    //   return 0;
    // cout << s << endl;
    // isr >> s;
    // if(isr.eof())   // at this point, isr is set to eof() state, so only 1 "test" is output
    //   return 0;
    // cout << s << endl;
    // isr >> s;
    // if(isr.eof())
    //   return 0;
    // cout << s << endl;

    // check if I can make a uniformly random number in [0, 1.0)
    // unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    // default_random_engine gen(seed);
    // uniform_real_distribution<double> distribution(0.0,1.0);
    // double rn{distribution(gen)};
    // cout << rn << endl;
    // cout << distribution(gen) << endl; // the 2nd call
    // return 0;
    // It seems the above code does.

    // Checks the functionality of rand_int().
    // cout << rand_int(1,3) << endl;
    // return 0;
    // rand_int(min, max) generates numbers including min and max.
    
    HW_game hwgame;
    hwgame.run();

    /*
      Review of Ex 12.
      Since its freedom is large (there is no specification of how many classes are to be used,
      or which class has what kinds of members), I was being confused about the overall
      class structure for the game.

      I started with conceptualizing what component the game has, and I thought there are 
      conceptually 2 components, 1 is the background, Cave class, and the other is 
      the user interface, HW_game, which deals with user's input and actions. I'm sure any
      way of conceptualization works, such as using only 1 class, but for designing a software,
      I think it's the important 1st step, to conceptualize the functionalities of the game, or
      software, and the software designer (I) confirm myself that the conceptualization
      (dividing the software into meaningful components, and understanding how those components
      interact with each other).
      
      Along with the conceptualization step, I looked up some websites (mainly wikipedia) to
      check the detailed rules of the game. The problem descriotion of the book is not detailed
      enough. For example, it doesn't tell if the Wumpus and a pit/bat can be in the same Room,
      or what happens when an invalid room numbers are entered for shooting an arrow, or
      more basically, whether it makes sense for an arrow to take turns in the middle of flying.
      I checked how the detailed rules, including the examples above and many more, were going 
      by looking up those information on the internet. For some detailed rules, I cannot find
      any information, such as whether a bat keeps staying in the same Room after it carries 
      the player to a random Room, and whether a bat can take the player to the Room where
      the Wumpus / a pit exists. For those rules that even the internet cannot tell, I applied 
      my own rules, so that they makes sense to me (for example, I made a rule that a bat can
      take the player to the Room with the Wumpus or a pit, because that makes the game more
      risky and thrilling).

      Then, along with further conceptualization, I started writing the code. But since it's
      almost impossible to foresee exactly what functionalities are needed for building the
      software I have designed, I anyway kept writing the code. Among them, there are some
      functionalities that turned out to be not necessary, for example, inside Cave class,
          enum Danger_type { BAT, PIT, WUMPUS, NO};
          Danger_type has_danger(int room_num){
	  // tells the caller what kinds of dangers exist in the specified Room
	  }
      This is just 1 example. On the other hands, there are many functionalities that I first
      thought not necessary, but were actually necessary, and I added to the game. For example,
      Command class that is used to read the player's command, and some member functions of Cave
      and HW_game class.
      But I think that it is the way to write a kind of big software, that we determine roughly
      in the 1st conceptualization phase, then as we keep writing the code, we keep 
      modifications to the functionalities and concepts on the fly.

      I don't know if there is better processes to write a big software (I'm sure there is),
      but at least this exercise is helpful to experience the whole processes, with 
      relatively a large freedom of software design.
     */

    
    return 0;
  }
  catch(exception& e){
    cerr << e.what() << endl;
    return 1;
  }
  catch(...){
    cerr << "Unknown error happens\n";
    return 1;
  }
